package main

import (
	"fmt"
	"time"
)

var currentSignalMatrix 	[3][N_Floors]int 
var previousSignalMatrix 	[3][N_Floors]int 
var previousFloorSensorSignal			 int 

type Order struct{
	floor 	int
	button 	int
}

//Funksjonen burde kanskje flyttes til en annen package
func addOrder(order Order, msg Msg){
	switch order.button{
	case BUTTON_CALL_UP: 
		msg.ExUpOrders[order.floor] = 1
	case BUTTON_CALL_DOWN:
		msg.ExDownOrders[order.floor] = 1
	case BUTTON_COMMAND:
		msg.InOrders[order.floor] = 1
	}
	//BÃ¸r kanskje flyttes
	Elev.set_button_lamp(Order.button, Order.floor, ON)	
}


func eventCreater(orderEventChannel chan Order, floorReachedEventChannel chan int){
	for floor:=0;floor<N_Floors;floor++{
		for button:=0;button<3;button++{
			currentSignalMatrix[button][floor] = Elev_get_button_signal(button,floor)
			if(currentSignalMatrix[button][floor] == 1 && previousSignalMatrix[button][floor] == 0){
				orderEventChannel <- Order{floor, button}
			}
			previousSignalMatrix[button][floor] = currentSignalMatrix[button][floor]
		}
	}
	if (Elev_get_floor_sensor_signal() != -1 && previousFloorSensorSignal == -1){
		floorReachedEvent <- Elev_get_floor_sensor_signal()
	}
	time.Sleep(10*time.Millisecond)
}


func eventHandler(){
	orderEventChannel := make(chan Order)
	floorReachedEventChannel := make(chan int)
	go eventCreater(orderEventChannel, floorReachedEventChannel)	
	for select{
	case order := <- orderEventChannel:
		fmt.Println("new order! , Floor: ",order.floor, ". Button: " , order.button )
		//videresend beskjed til andre heiser om at ny ordre legges til. 
		//addOrder()
	case floor := <- floorReachedEventChannel:
		fmt.Println("New floor reached :", floor)
		floorReached()
	}
}





func main(){
	eventHandler()
}



